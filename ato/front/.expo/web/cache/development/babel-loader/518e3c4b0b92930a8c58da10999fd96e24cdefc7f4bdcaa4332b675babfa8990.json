{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _excluded = [\"uri\"];\nvar _getPermissionWithQueryAsync, _setStatusForMedia, _getStatusForVideo, _loadForVideo, _unloadForVideo, _setStatusForVideo, _replayVideo, _setAudioMode, _setAudioIsEnabled, _getStatusForSound, _loadForSound, _unloadForSound, _setStatusForSound, _replaySound, _getAudioRecordingStatus, _prepareAudioRecorder, _startAudioRecording, _pauseAudioRecording, _stopAudioRecording, _unloadAudioRecorder, _getPermissionsAsync, _requestPermissionsAsync;\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\nimport { RecordingOptionsPresets } from \"./Audio/RecordingConstants\";\nfunction getPermissionWithQueryAsync(_x) {\n  return (_getPermissionWithQueryAsync = _getPermissionWithQueryAsync || _asyncToGenerator(function* (name) {\n    if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n    try {\n      var _yield$navigator$perm = yield navigator.permissions.query({\n          name: name\n        }),\n        state = _yield$navigator$perm.state;\n      switch (state) {\n        case 'granted':\n          return PermissionStatus.GRANTED;\n        case 'denied':\n          return PermissionStatus.DENIED;\n        default:\n          return PermissionStatus.UNDETERMINED;\n      }\n    } catch (_unused) {\n      return PermissionStatus.UNDETERMINED;\n    }\n  })).apply(this, arguments);\n}\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n  var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {\n    var error = new Error('Permission unimplemented');\n    error.code = 0;\n    error.name = 'NotAllowedError';\n    throw error;\n  };\n  return new Promise(function (resolve, reject) {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n  var isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  var status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    shouldPlay: media.autoplay,\n    isPlaying: isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\nfunction setStatusForMedia(_x2, _x3) {\n  return (_setStatusForMedia = _setStatusForMedia || _asyncToGenerator(function* (media, status) {\n    if (status.positionMillis !== undefined) {\n      media.currentTime = status.positionMillis / 1000;\n    }\n    if (status.shouldPlay !== undefined) {\n      if (status.shouldPlay) {\n        yield media.play();\n      } else {\n        yield media.pause();\n      }\n    }\n    if (status.rate !== undefined) {\n      media.playbackRate = status.rate;\n    }\n    if (status.volume !== undefined) {\n      media.volume = status.volume;\n    }\n    if (status.isMuted !== undefined) {\n      media.muted = status.isMuted;\n    }\n    if (status.isLooping !== undefined) {\n      media.loop = status.isLooping;\n    }\n    return getStatusFromMedia(media);\n  })).apply(this, arguments);\n}\nvar mediaRecorder = null;\nvar mediaRecorderUptimeOfLastStartResume = 0;\nvar mediaRecorderDurationAlreadyRecorded = 0;\nvar mediaRecorderIsRecording = false;\nfunction getAudioRecorderDurationMillis() {\n  var duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\nexport default {\n  get name() {\n    return 'ExponentAV';\n  },\n  getStatusForVideo: function getStatusForVideo(_x4) {\n    return (_getStatusForVideo = _getStatusForVideo || _asyncToGenerator(function* (element) {\n      return getStatusFromMedia(element);\n    })).apply(this, arguments);\n  },\n  loadForVideo: function loadForVideo(_x5, _x6, _x7) {\n    return (_loadForVideo = _loadForVideo || _asyncToGenerator(function* (element, nativeSource, fullInitialStatus) {\n      return getStatusFromMedia(element);\n    })).apply(this, arguments);\n  },\n  unloadForVideo: function unloadForVideo(_x8) {\n    return (_unloadForVideo = _unloadForVideo || _asyncToGenerator(function* (element) {\n      return getStatusFromMedia(element);\n    })).apply(this, arguments);\n  },\n  setStatusForVideo: function setStatusForVideo(_x9, _x10) {\n    return (_setStatusForVideo = _setStatusForVideo || _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    })).apply(this, arguments);\n  },\n  replayVideo: function replayVideo(_x11, _x12) {\n    return (_replayVideo = _replayVideo || _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    })).apply(this, arguments);\n  },\n  setAudioMode: function setAudioMode() {\n    return (_setAudioMode = _setAudioMode || _asyncToGenerator(function* () {})).apply(this, arguments);\n  },\n  setAudioIsEnabled: function setAudioIsEnabled() {\n    return (_setAudioIsEnabled = _setAudioIsEnabled || _asyncToGenerator(function* () {})).apply(this, arguments);\n  },\n  getStatusForSound: function getStatusForSound(_x13) {\n    return (_getStatusForSound = _getStatusForSound || _asyncToGenerator(function* (element) {\n      return getStatusFromMedia(element);\n    })).apply(this, arguments);\n  },\n  loadForSound: function loadForSound(_x14, _x15) {\n    return (_loadForSound = _loadForSound || _asyncToGenerator(function* (nativeSource, fullInitialStatus) {\n      var source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n      var media = new Audio(source);\n      media.ontimeupdate = function () {\n        SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n          key: media,\n          status: getStatusFromMedia(media)\n        });\n      };\n      media.onerror = function () {\n        SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n          key: media,\n          error: media.error.message\n        });\n      };\n      var status = yield setStatusForMedia(media, fullInitialStatus);\n      return [media, status];\n    })).apply(this, arguments);\n  },\n  unloadForSound: function unloadForSound(_x16) {\n    return (_unloadForSound = _unloadForSound || _asyncToGenerator(function* (element) {\n      element.pause();\n      element.removeAttribute('src');\n      element.load();\n      return getStatusFromMedia(element);\n    })).apply(this, arguments);\n  },\n  setStatusForSound: function setStatusForSound(_x17, _x18) {\n    return (_setStatusForSound = _setStatusForSound || _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    })).apply(this, arguments);\n  },\n  replaySound: function replaySound(_x19, _x20) {\n    return (_replaySound = _replaySound || _asyncToGenerator(function* (element, status) {\n      return setStatusForMedia(element, status);\n    })).apply(this, arguments);\n  },\n  getAudioRecordingStatus: function getAudioRecordingStatus() {\n    return (_getAudioRecordingStatus = _getAudioRecordingStatus || _asyncToGenerator(function* () {\n      var _mediaRecorder, _mediaRecorder2, _mediaRecorder3;\n      return {\n        canRecord: ((_mediaRecorder = mediaRecorder) == null ? void 0 : _mediaRecorder.state) === 'recording' || ((_mediaRecorder2 = mediaRecorder) == null ? void 0 : _mediaRecorder2.state) === 'inactive',\n        isRecording: ((_mediaRecorder3 = mediaRecorder) == null ? void 0 : _mediaRecorder3.state) === 'recording',\n        isDoneRecording: false,\n        durationMillis: getAudioRecorderDurationMillis(),\n        uri: null\n      };\n    })).apply(this, arguments);\n  },\n  prepareAudioRecorder: function prepareAudioRecorder(_x21) {\n    return (_prepareAudioRecorder = _prepareAudioRecorder || _asyncToGenerator(function* (options) {\n      if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n        throw new Error('No media devices available');\n      }\n      mediaRecorderUptimeOfLastStartResume = 0;\n      mediaRecorderDurationAlreadyRecorded = 0;\n      var stream = yield getUserMedia({\n        audio: true\n      });\n      mediaRecorder = new window.MediaRecorder(stream, (options == null ? void 0 : options.web) || RecordingOptionsPresets.HIGH_QUALITY.web);\n      mediaRecorder.addEventListener('pause', function () {\n        mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n        mediaRecorderIsRecording = false;\n      });\n      mediaRecorder.addEventListener('resume', function () {\n        mediaRecorderUptimeOfLastStartResume = Date.now();\n        mediaRecorderIsRecording = true;\n      });\n      mediaRecorder.addEventListener('start', function () {\n        mediaRecorderUptimeOfLastStartResume = Date.now();\n        mediaRecorderDurationAlreadyRecorded = 0;\n        mediaRecorderIsRecording = true;\n      });\n      mediaRecorder.addEventListener('stop', function () {\n        mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n        mediaRecorderIsRecording = false;\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n      });\n      var _yield$this$getAudioR = yield this.getAudioRecordingStatus(),\n        uri = _yield$this$getAudioR.uri,\n        status = _objectWithoutProperties(_yield$this$getAudioR, _excluded);\n      return {\n        uri: null,\n        status: status\n      };\n    })).apply(this, arguments);\n  },\n  startAudioRecording: function startAudioRecording() {\n    return (_startAudioRecording = _startAudioRecording || _asyncToGenerator(function* () {\n      if (mediaRecorder === null) {\n        throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n      }\n      if (mediaRecorder.state === 'paused') {\n        mediaRecorder.resume();\n      } else {\n        mediaRecorder.start();\n      }\n      return this.getAudioRecordingStatus();\n    })).apply(this, arguments);\n  },\n  pauseAudioRecording: function pauseAudioRecording() {\n    return (_pauseAudioRecording = _pauseAudioRecording || _asyncToGenerator(function* () {\n      if (mediaRecorder === null) {\n        throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n      }\n      mediaRecorder.pause();\n      return this.getAudioRecordingStatus();\n    })).apply(this, arguments);\n  },\n  stopAudioRecording: function stopAudioRecording() {\n    return (_stopAudioRecording = _stopAudioRecording || _asyncToGenerator(function* () {\n      if (mediaRecorder === null) {\n        throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n      }\n      if (mediaRecorder.state === 'inactive') {\n        return this.getAudioRecordingStatus();\n      }\n      var dataPromise = new Promise(function (resolve) {\n        return mediaRecorder.addEventListener('dataavailable', function (e) {\n          return resolve(e.data);\n        });\n      });\n      mediaRecorder.stop();\n      var data = yield dataPromise;\n      var url = URL.createObjectURL(data);\n      return _objectSpread(_objectSpread({}, yield this.getAudioRecordingStatus()), {}, {\n        uri: url\n      });\n    })).apply(this, arguments);\n  },\n  unloadAudioRecorder: function unloadAudioRecorder() {\n    return (_unloadAudioRecorder = _unloadAudioRecorder || _asyncToGenerator(function* () {\n      mediaRecorder = null;\n    })).apply(this, arguments);\n  },\n  getPermissionsAsync: function getPermissionsAsync() {\n    return (_getPermissionsAsync = _getPermissionsAsync || _asyncToGenerator(function* () {\n      var maybeStatus = yield getPermissionWithQueryAsync('microphone');\n      switch (maybeStatus) {\n        case PermissionStatus.GRANTED:\n          return {\n            status: PermissionStatus.GRANTED,\n            expires: 'never',\n            canAskAgain: true,\n            granted: true\n          };\n        case PermissionStatus.DENIED:\n          return {\n            status: PermissionStatus.DENIED,\n            expires: 'never',\n            canAskAgain: true,\n            granted: false\n          };\n        default:\n          return yield this.requestPermissionsAsync();\n      }\n    })).apply(this, arguments);\n  },\n  requestPermissionsAsync: function requestPermissionsAsync() {\n    return (_requestPermissionsAsync = _requestPermissionsAsync || _asyncToGenerator(function* () {\n      try {\n        var stream = yield getUserMedia({\n          audio: true\n        });\n        stream.getTracks().forEach(function (track) {\n          return track.stop();\n        });\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true\n        };\n      } catch (_unused2) {\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false\n        };\n      }\n    })).apply(this, arguments);\n  }\n};","map":{"version":3,"names":["PermissionStatus","SyntheticPlatformEmitter","RecordingOptionsPresets","getPermissionWithQueryAsync","_x","_getPermissionWithQueryAsync","_asyncToGenerator","name","navigator","permissions","query","_yield$navigator$perm","state","GRANTED","DENIED","UNDETERMINED","_unused","apply","arguments","getUserMedia","constraints","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","Promise","resolve","reject","call","getStatusFromMedia","media","isLoaded","undefined","isPlaying","currentTime","paused","ended","readyState","status","uri","src","progressUpdateIntervalMillis","durationMillis","duration","positionMillis","shouldPlay","autoplay","isBuffering","rate","playbackRate","shouldCorrectPitch","volume","audioPan","isMuted","muted","isLooping","loop","didJustFinish","setStatusForMedia","_x2","_x3","_setStatusForMedia","play","pause","mediaRecorder","mediaRecorderUptimeOfLastStartResume","mediaRecorderDurationAlreadyRecorded","mediaRecorderIsRecording","getAudioRecorderDurationMillis","Date","now","getStatusForVideo","_x4","_getStatusForVideo","element","loadForVideo","_x5","_x6","_x7","_loadForVideo","nativeSource","fullInitialStatus","unloadForVideo","_x8","_unloadForVideo","setStatusForVideo","_x9","_x10","_setStatusForVideo","replayVideo","_x11","_x12","_replayVideo","setAudioMode","_setAudioMode","setAudioIsEnabled","_setAudioIsEnabled","getStatusForSound","_x13","_getStatusForSound","loadForSound","_x14","_x15","_loadForSound","source","Audio","ontimeupdate","emit","key","onerror","message","unloadForSound","_x16","_unloadForSound","removeAttribute","load","setStatusForSound","_x17","_x18","_setStatusForSound","replaySound","_x19","_x20","_replaySound","getAudioRecordingStatus","_getAudioRecordingStatus","_mediaRecorder","_mediaRecorder2","_mediaRecorder3","canRecord","isRecording","isDoneRecording","prepareAudioRecorder","_x21","_prepareAudioRecorder","options","stream","audio","window","MediaRecorder","web","HIGH_QUALITY","addEventListener","getTracks","forEach","track","stop","_yield$this$getAudioR","_objectWithoutProperties","_excluded","startAudioRecording","_startAudioRecording","resume","start","pauseAudioRecording","_pauseAudioRecording","stopAudioRecording","_stopAudioRecording","dataPromise","e","data","url","URL","createObjectURL","_objectSpread","unloadAudioRecorder","_unloadAudioRecorder","getPermissionsAsync","_getPermissionsAsync","maybeStatus","expires","canAskAgain","granted","requestPermissionsAsync","_requestPermissionsAsync","_unused2"],"sources":["C:\\Users\\Fabiola\\Music\\desktop\\projet\\front\\node_modules\\expo-av\\src\\ExponentAV.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RecordingOptionsPresets } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch {\n    // Firefox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    audioPan: 0,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nasync function setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): Promise<AVPlaybackStatus> {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      await media.play();\n    } else {\n      await media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = await setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RecordingOptionsPresets.HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise<Blob>((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}